import React, { useState, useEffect } from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";
import { 
  BarChart3, 
  Calculator, 
  Download, 
  Layers,
  LineChart, 
  MapPin,
  Settings, 
  Sun,
  Zap,
  Brain,
  Sparkles,
  ChevronRight,
  Cpu,
  Activity
} from "lucide-react";
import { calculateSolarEnergy, calculateMultiplePVSystems, MultiplePVSystemsParams } from "@/utils/solarEnergyCalculation";
import { InverterParams, SolarCalculationResult, SolarParams } from "@/types/solarCalculations";
import { PolygonConfig } from "./area-calculator/types";
import SystemConfiguration from "../advanced-solar-calculator/SystemConfiguration";
import ComponentSelector from "./ComponentSelector";
import EfficiencyAdjustment from "./EfficiencyAdjustment";
import ProductionResults from "./ProductionResults";
import AreaCalculator from "./AreaCalculator";
import LocationInputs from "../advanced-solar-inputs/LocationInputs";
import { Card } from "@/components/ui/card";
import { getArrayTypeForStructure } from "./area-calculator/utils/drawingUtils";
import SystemLosses from "../advanced-solar-calculator/SystemLosses";

const AdvancedSolarCalculator: React.FC = () => {
  // Location parameters
  const [latitude, setLatitude] = useState(40.7128);
  const [longitude, setLongitude] = useState(-74.0060);
  const [timezone, setTimezone] = useState("America/New_York");
  const [country, setCountry] = useState("United States");
  const [city, setCity] = useState("New York");
  
  // PV system parameters
  const [tilt, setTilt] = useState(30);
  const [azimuth, setAzimuth] = useState(180); // 180 = south
  const [arrayType, setArrayType] = useState(0); // 0 = Fixed (open rack)
  const [losses, setLosses] = useState(14.08); // Default value
  const [moduleEfficiency, setModuleEfficiency] = useState(0.2); // 20%
  const [performanceRatio, setPerformanceRatio] = useState(0.8); // 80%
  const [capacity, setCapacity] = useState(10); // 10 kW
  const [moduleArea, setModuleArea] = useState(1.7); // mÂ²
  const [moduleWattPeak, setModuleWattPeak] = useState(400); // Wp
  
  // Component selection
  const [selectedPanel, setSelectedPanel] = useState(null);
  const [selectedInverter, setSelectedInverter] = useState(null);
  
  // Area calculation results
  const [areaBasedLayout, setAreaBasedLayout] = useState(null);
  const [polygonConfigs, setPolygonConfigs] = useState([]);
  
  // Inverter configuration
  const [inverterParams, setInverterParams] = useState<InverterParams | null>(null);
  const [dcAcRatio, setDcAcRatio] = useState(120); // Fixed value
  
  // Results state
  const [results, setResults] = useState<SolarCalculationResult | null>(null);
  const [calculating, setCalculating] = useState(false);
  const [activeTab, setActiveTab] = useState("components");
  
  // Step tracking
  const [currentStep, setCurrentStep] = useState(1);
  const [completedSteps, setCompletedSteps] = useState<Record<number, boolean>>({});
  // When components are selected, automatically go to location tab
  useEffect(() => {
    if (selectedPanel && selectedInverter) {
      setCompletedSteps(prev => ({...prev, 1: true}));
      updateModuleParameters();
    }
  }, [selectedPanel, selectedInverter]);
  
  // Update module parameters when panel is selected
  const updateModuleParameters = () => {
    if (selectedPanel) {
      // Extract panel dimensions and calculate area, with proper fallbacks
      let panelArea = 0;
      
      // First check for explicit panel_area_m2 field
      if (selectedPanel.panel_area_m2 && selectedPanel.panel_area_m2 > 0) {
        panelArea = selectedPanel.panel_area_m2;
        console.log(`Using panel_area_m2 directly: ${panelArea.toFixed(3)}mÂ²`);
      } 
      // Then check for module_length and module_width fields (in mm)
      else if (selectedPanel.module_length && selectedPanel.module_width) {
        panelArea = (selectedPanel.module_length * selectedPanel.module_width) / 1000000;
        console.log(`Using module_length Ã— module_width: ${panelArea.toFixed(3)}mÂ²`);
      }
      // Then check for length and width fields (in mm)
      else if (selectedPanel.length && selectedPanel.width) {
        panelArea = (selectedPanel.length * selectedPanel.width) / 1000000;
        console.log(`Using length Ã— width: ${panelArea.toFixed(3)}mÂ²`);
      }
      // Finally fall back to standard dimensions
      else {
        const defaultLength = 1700; // mm
        const defaultWidth = 1000; // mm
        panelArea = (defaultLength * defaultWidth) / 1000000;
        console.log(`Using default dimensions: ${panelArea.toFixed(3)}mÂ²`);
      }
      
      // Correctly extract panel efficiency from all possible fields
      let panelEfficiency = 20; // default fallback %
      
      if (selectedPanel.efficiency_percent && selectedPanel.efficiency_percent > 0) {
        panelEfficiency = selectedPanel.efficiency_percent;
        console.log(`Using panel efficiency_percent: ${panelEfficiency}%`);
      } else if (selectedPanel.efficiency && selectedPanel.efficiency > 0) {
        // Handle efficiency as decimal or percentage
        panelEfficiency = selectedPanel.efficiency > 1 ? selectedPanel.efficiency : selectedPanel.efficiency * 100;
        console.log(`Using panel efficiency: ${panelEfficiency}%`);
      }
      
      // Enhanced panel power extraction
      let panelPower = 0;
      
      console.log('SelectedPanel object:', selectedPanel);
      
      const possiblePowerFields = [
        'nominal_power_w',
        'power_rating',
        'power',
        'wattage',
        'watt_peak',
        'max_power',
        'pmax',
        'rated_power',
        'module_power',
        'wp',
        'w',
      ];
      
      for (const field of possiblePowerFields) {
        let value = selectedPanel[field];
        if (typeof value === 'string') {
          value = parseFloat(value.replace(/[^\d.]/g, ''));
        }
        if (typeof value === 'number' && value > 0) {
          panelPower = value;
          console.log(`Panel power found in field '${field}':`, panelPower);
          break;
        }
      }
      
      // Handle the specific error case (34kW bug)
      if (panelPower > 30000 && panelPower < 40000) {
        panelPower = panelPower / 100;
        console.log(`Converting specific error case panel from 34kW to ${panelPower}W`);
      }
      
      if (!panelPower || panelPower <= 0) {
        // Calculate power from area and efficiency as fallback
        panelPower = Math.round(panelArea * 1000 * panelEfficiency);
        console.warn('No power value available - calculating from area and efficiency:', panelPower);
      }
      
      setModuleArea(panelArea);
      setModuleEfficiency(panelEfficiency / 100);
      setModuleWattPeak(panelPower);
      
      console.log(`Panel parameters updated: ${panelArea.toFixed(2)}mÂ², ${panelEfficiency}%, ${panelPower}W`);
    }
  };
  // Enhance the handleAreaCalculation function with additional debugging and safeguards
  const handleAreaCalculation = (capacityKw: number, areaM2: number, moduleCount: number, configs?: PolygonConfig[]) => {
    console.log("Area calculation received:", { capacityKw, areaM2, moduleCount, configCount: configs?.length });
    
    // Validate incoming data
    if (isNaN(capacityKw) || capacityKw === undefined) {
      console.error("Invalid capacity value received:", capacityKw);
      capacityKw = 0;
    }
    
    if (moduleCount > 0 && capacityKw === 0) {
      console.warn("Modules placed but capacity is zero - recalculating");
      // More robust panel power determination with improved consistency
      console.log("Selected panel for capacity calculation:", selectedPanel);
      
      let panelPower = 0;
      
      // Check for nominal_power_w first as it's the most reliable source
      if (selectedPanel?.nominal_power_w && selectedPanel.nominal_power_w > 0) {
        panelPower = selectedPanel.nominal_power_w;
        console.log(`Using nominal_power_w: ${panelPower}W`);
      }
      // ONLY handle the specific edge case of 34kW panels
      else if (selectedPanel?.power_rating && selectedPanel.power_rating > 30000 && selectedPanel.power_rating < 40000) {
        panelPower = selectedPanel.power_rating / 100; // Convert from 34000W to 340W
        console.log(`Converting specific error case panel from ${selectedPanel.power_rating}W to ${panelPower}W`);
      } 
      else if (selectedPanel?.power && selectedPanel.power > 30000 && selectedPanel.power < 40000) {
        panelPower = selectedPanel.power / 100; // Convert from 34000W to 340W
        console.log(`Converting specific error case panel from ${selectedPanel.power}W to ${panelPower}W`);
      }
      // For all other values, use the actual power values
      else if (selectedPanel?.power_rating && selectedPanel.power_rating > 0) {
        panelPower = selectedPanel.power_rating;
        console.log(`Using actual panel power_rating: ${panelPower}W`);
      } 
      else if (selectedPanel?.power && selectedPanel.power > 0) {
        panelPower = selectedPanel.power;
        console.log(`Using actual panel power: ${panelPower}W`);
      } 
      else {
        // Use default panel power if no valid value found
        panelPower = 400;
        console.warn("No valid panel power found, using default:", panelPower);
      }
      
      // Calculate capacity with the extracted power value
      capacityKw = (moduleCount * panelPower) / 1000;
      console.log("Recalculated capacity:", capacityKw.toFixed(2), "kW from", moduleCount, "modules at", panelPower, "W each");
    }
    
    setAreaBasedLayout({
      capacityKw,
      areaM2,
      moduleCount
    });
    
    // Update the PV capacity based on actual placed modules
    if (capacityKw > 0) {
      console.log(`Setting system capacity to ${capacityKw.toFixed(2)} kW`);
      setCapacity(capacityKw);
    } else {
      console.warn("Zero capacity value - check panel power rating");
    }
    
    // Store polygon configurations for PVWatts
    if (configs && configs.length > 0) {
      console.log("Using polygon configs:", configs);
      setPolygonConfigs(configs);
      
      // Update tilt and azimuth based on first polygon
      setTilt(configs[0].tiltAngle);
      setAzimuth(configs[0].azimuth);
      
      // Automatically assign array type based on structure types
      const structureTypes = configs.map(config => config.structureType);
      const uniqueStructureTypes = [...new Set(structureTypes)];
      
      // If all areas use the same structure type, use that mapping
      if (uniqueStructureTypes.length === 1) {
        const arrayType = getArrayTypeForStructure(uniqueStructureTypes[0]);
        setArrayType(arrayType);
        console.log(`Auto-assigned array type ${arrayType} for structure type: ${uniqueStructureTypes[0]}`);
      } 
      // If mixed structure types, prioritize ballasted (roof mount) if present, otherwise use open rack
      else {
        const hasBallasted = structureTypes.includes('ballasted');
        const arrayType = hasBallasted ? 1 : 0; // Roof mount if ballasted present, otherwise open rack
        setArrayType(arrayType);
        console.log(`Mixed structure types detected. Auto-assigned array type ${arrayType} (prioritizing ${hasBallasted ? 'roof mount for ballasted' : 'open rack'})`);
      }
      
      // Mark the area definition step as completed
      setCompletedSteps(prev => ({...prev, 3: true}));
    } else {
      console.log("No polygon configurations received");
      setPolygonConfigs([]);
    }
  };
  // Calculate inverter parameters based on capacity
  useEffect(() => {
    if (selectedInverter && capacity > 0) {
      const inverterPowerKw = selectedInverter.power_rating || selectedInverter.nominal_ac_power_kw || 1;
      const suggestedInverterCount = Math.max(1, Math.ceil(capacity / inverterPowerKw / (dcAcRatio / 100)));
      
      setInverterParams({
        inverter_model: selectedInverter.model || selectedInverter.id,
        quantity: suggestedInverterCount,
        dc_ac_ratio: dcAcRatio / 100,
        power: inverterPowerKw,
        efficiency: selectedInverter.efficiency || 0.96
      });
    }
  }, [selectedInverter, capacity, dcAcRatio]);
  const handleCalculate = () => {
    setCalculating(true);
    
    try {
      // Validate required parameters
      if (!latitude || !longitude) {
        throw new Error("Missing location parameters. Please set latitude and longitude.");
      }
      
      if (!polygonConfigs || polygonConfigs.length === 0) {
        throw new Error("No PV areas defined. Please draw at least one PV area.");
      }
      
      if (!selectedPanel || !selectedInverter) {
        throw new Error("Missing component selection. Please select both panel and inverter.");
      }

      console.log("Starting multiple PV systems calculation with:", {
        latitude,
        longitude,
        timezone,
        systemCount: polygonConfigs.length,
        totalCapacity: capacity
      });

      // Prepare parameters for multiple PV systems
      const params: MultiplePVSystemsParams = {
        latitude,
        longitude,
        timezone,
        module_efficiency: moduleEfficiency,
        performance_ratio: performanceRatio,
        module_area: moduleArea,
        module_watt_peak: moduleWattPeak,
        inverterParams,
        losses: losses,
        pvSystems: polygonConfigs.map(config => ({
          structureType: config.structureType,
          area: config.area,
          moduleCount: config.moduleCount,
          capacityKw: config.capacityKw,
          azimuth: config.azimuth,
          tiltAngle: config.tiltAngle
        }))
      };
      
      // Calculate solar energy for multiple PV systems
      const calculationResults = calculateMultiplePVSystems(params);
      setResults(calculationResults);
      setActiveTab("results");
      
      toast.success(`Solar energy calculations completed for ${polygonConfigs.length} PV system(s)!`);
      
      // Mark all steps as completed when calculations are done
      setCompletedSteps({1: true, 2: true, 3: true, 4: true});
    } catch (error) {
      console.error("Calculation error:", error);
      toast.error(error instanceof Error ? error.message : "Error in solar calculations");
    } finally {
      setCalculating(false);
    }
  };
  
  // Update step completion status
  useEffect(() => {
    const newCompletedSteps = { ...completedSteps };
    let hasChanged = false;
    
    // Step 1: Components selected
    if (selectedPanel && selectedInverter) {
      if (!newCompletedSteps[1]) {
        newCompletedSteps[1] = true;
        hasChanged = true;
      }
    } else if (newCompletedSteps[1]) {
      newCompletedSteps[1] = false;
      hasChanged = true;
    }
    
    // Step 2: Location parameters defined
    if (latitude && longitude) {
      if (!newCompletedSteps[2]) {
        newCompletedSteps[2] = true;
        hasChanged = true;
      }
    } else if (newCompletedSteps[2]) {
      newCompletedSteps[2] = false;
      hasChanged = true;
    }
    
    // Step 4: Configuration parameters set
    // We'll consider this done if the user has visited the tab
    if (activeTab === 'configuration' && !newCompletedSteps[4]) {
      newCompletedSteps[4] = true;
      hasChanged = true;
    }
    
    // Only update state if something actually changed
    if (hasChanged) {
      setCompletedSteps(newCompletedSteps);
    }
  }, [selectedPanel, selectedInverter, latitude, longitude, activeTab]);
  
  // Update current step based on active tab
  useEffect(() => {
    switch(activeTab) {
      case 'components':
        setCurrentStep(1);
        break;
      case 'location':
        setCurrentStep(2);
        break;
      case 'areas':
        setCurrentStep(3);
        break;
      case 'configuration':
        setCurrentStep(4);
        break;
      case 'results':
        setCurrentStep(5);
        break;
      default:
        setCurrentStep(1);
    }
  }, [activeTab]);
  return (
    <div className="w-full max-w-6xl mx-auto pb-8">
      {/* Progress Bar */}
      <div className="sticky top-0 pt-4 pb-2 bg-white z-10 border-b mb-6">
        <div className="w-full max-w-6xl mx-auto">
